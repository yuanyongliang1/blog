---
title: redisPersistence
date: 2024-02-21 15:21:32
tags:
 - redis持久化
categories:
 - redis
---



#### redis持久化

redis持久化分为RDB和AOF:

​	RDB：RDB持久化就是在指定时间间隔内将内存中的数据集快照写入磁盘，也就是`snapshot`，它恢复时是直接将快照文件直接读到内存里。

RDB触发的方式有几种：两种，分别是手动触发和自动触发

| 触发方式 | 实现方式                 | 特性                                                         |
| -------- | ------------------------ | ------------------------------------------------------------ |
| 手动触发 | save命令                 | 这个指令会直接阻塞当前redis服务器，直到RDB完成了为止         |
|          | bgsave命令               | 主进程fork一个子进程，由子进程完成持久化操作，<br />而主进程继续处理客户端的读写请求，<br />如果需要手动实现持久化，推荐使用这这种方式 |
| 自动触发 | 配置redis.conf的save参数 | save 20 3 代表的是在20s内写入3次就进行持久化                 |

**bgsave的工作流程：**

- 主进程fork出一个子进程，这时候主进程会被阻塞
- 子进程创建完成后，`redis`客户端会输出 `Background saving started`,这就意味着子进程开始进行持久化操作了	
- 子进程持久化完成后会生成一个rdb文件，将本次的rdb文件通过原子替换的方式将上一次备份的rdb文件覆盖
- 子进程发送信号通知父进程本次任务完成

**RDB常见的配置参数**

| 参数           | 作用                                                         |
| -------------- | ------------------------------------------------------------ |
| dbfilename     | 指定rdb的文件名                                              |
| dir            | 指定rdb文件的持久化位置，默认取redis服务端的位置             |
| rdbcompression | 开启后redis默认使用LZF算法压缩rdb文件，这种方式会消耗CPU，但是压缩后的大小远远小于内存 |
|                |                                                              |

**RDB的优点和缺点：**

|      |                                                              |
| ---- | ------------------------------------------------------------ |
| 优点 | RDB是一个紧凑的单一文件，很方便传送到另一个远端数据中心，非常适合用于灾难回复<br />在恢复较大的数据集时，RDb方式会更快一些 |
| 缺点 | RDB没办法做到实时持久化，bgsave每次fork子进程都会阻塞，频繁执行成本较高<br />在一定间隔时间做备份，如果redis意外down掉，就会丢失最后一次快照之后的所有修改 |

**AOF：**默认情况下，redis没有开启AOF，开启配置需要在配置文件中将`appendonly` 改为 yes，AOF会以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来，只需追加文件不许修改文件，`redis`启动时会读取该文件重新构建数据。

**AOF的触发类型：**

| 参数                  | 参数说明                                                     |
| :-------------------- | ------------------------------------------------------------ |
| appendfsync always    | 同步持久化，每次放生数据变化就会立马写入磁盘，新能比较差但数据完整性比较好 |
| appendfsync  everysec | 默认推荐，每次异步记录一次                                   |
| appendfsync no        | 不同步                                                       |

**配置重写触发机制：**

```
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
```

**参数说明：**当AOF文件大小是上一次大小的一倍并且大于64mb时触发

**根据AOF恢复数据：**

正常情况下，将`appendonly.aof`文件复制到bin目录下，并且重启`redis`服务即可，在实际开发中，文件会存储在网络设备上，保障数据高可靠，如果因为某些原因导致`appendonly.aof`文件格式异常，从而导致数据还原失败，可以通过命令`redis-check-aof --fix appendonly.aof`进行修复

**AOF的重写压缩机制：**

AOF的工作原理将每次写操作追加到文件中，这样文件会出现很多冗余内容，所以redis新增了重写机制

AOF可以生成一个新的AOF文件，新文件和老文件保存的信息一样，但体积更小，还可以做命令的合并，进而节省了redis的储存空间

**AOF重写流程：**

- 把主线程的内存拷贝一份给fork出来的`bgrewiteaof`子进程，这里面包含lredis最新的数据
- 子进程将其中的数据进行重写。
- 主线程在重写时候维护一个AOF重写缓冲区，将重写过程中的写操作记录，计入其中，保证重写后的AOF日志也能记录在重写过程中产生的新数据 
- 用新AOF替换老AOF

**AOF的优点和缺点：**

|      |                                                             |
| ---- | ----------------------------------------------------------- |
| 优点 | 数据的完整性和一致性更高                                    |
| 缺点 | 因为AOF记录的内容多，文件只会越来越大，数据恢复也会越来越慢 |

