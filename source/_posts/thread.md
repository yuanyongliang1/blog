---
title: threadLifecycle
date: 2024-02-23 14:12:25
tags: 
 - 线程的生命周期
categories: 
 - 线程
---

#### 进程与线程的区别

1、本质不同

进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元。

2、数量不同

同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进行至少包括一个线程。

3、过程不同

进程的创建调用fork或者vfork，而线程的创建调用pthread_create，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束。

4、属性不同

线程有自己的私有属性TCB，线程id，寄存器、硬件上下文，而进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志。

**进程：**是资源分配的最小单位，一个进程可以有多个线程，多个线程共享进程的堆和方法区资源，不共享栈、程序计数器

**线程：**是任务调度和执行的最小单位，线程并行执行存在资源竞争和上下文切换的问题

**协程：**是一种比线程更加轻量级的存在，正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程。



#### 进程间通信方式IPC

**管道pipe：**亲缘关系使用匿名管道，非亲缘关系使用命名管道，管道遵循FIFO，半双工，数据只能单向通信；

**信号：**信号是一种比较复杂的通信方式，用户调用kill命令将信号发送给其他进程。

**消息队列：**消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点。

**共享内存(share memory)：**

- 使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。
- 由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。

**信号量(Semaphores) ：**信号量是⼀个计数器，⽤于多进程对共享数据的访问，这种通信⽅式主要⽤于解决与同步相关的问题并避免竞争条件。

**套接字(Sockets) :** 简单的说就是通信的两⽅的⼀种约定，⽤套接字中的相关函数来完成通信过程。

#### 并行与串行的区别

串行就是在主线程上按顺序执行逻辑代码

并行就是多个cpu同时工作来完成多个逻辑

#### java实现多线程的三种的方式

继承Thread类、实现Runnable接口、使用ExecutorService、Callable、Future实现有返回结果的多线程。其中前两种方式线程执行完后都没有返回值，只有最后一种是带返回值的。

####  线程常用API

| 方法            | 名称                                        |
| --------------- | ------------------------------------------- |
| start()         | 启动线程                                    |
| currentThread() | 获取当前线程对象                            |
| getId()         | 获取当前线程id                              |
| getName()       | 获取当前线程名称                            |
| sleep()         | 休眠线程                                    |
| stop()          | 停止线程 --不安全 --不推荐使用              |
| setDaemon()     | 改变线程状态:true-守护线程:flase-非守护线程 |
| join()          | 线程执行优先级                              |

#### 线程的生命周期

当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，它要经过 **新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）和死亡（Dead）5种状态**。尤其是当线程启动以后，它不可能一直"霸占"着CPU独自运行，所以CPU需要在多条线程之间切换，于是 线程状态也会多次在运行、阻塞之间切换。

1.当程序使用new关键字创建了一个线程之后，该线程就处于 **新建状态**

2.当线程对象调用了start()方法之后，该线程处于 **就绪状态**。

3.当CPU开始调度处于 **就绪状态** 的线程时，此时线程获得了CPU时间片才得以真正开始执行run()方法的线程执行体，则该线程处于 **运行状态**。

4.处于运行状态的线程在某些情况下，让出CPU并暂时停止自己的运行，进入 **阻塞状态**。

5.线程会以下三种方式结束就会进入**死亡状态**	

​	run()或call()方法执行完成，线程正常结束；

​	线程抛出一个未捕获的Exception或Error；

​	直接调用该线程stop()方法来结束该线程,—该方法容易导致死锁，通常不推荐使用；