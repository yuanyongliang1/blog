---
title: threadLifecycle
date: 2024-02-23 14:12:25
tags: 
 - 线程的生命周期
categories: 
 - 线程
---

#### 进程与线程的区别

1、本质不同

进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元。

2、数量不同

同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进行至少包括一个线程。

3、过程不同

进程的创建调用fork或者vfork，而线程的创建调用pthread_create，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束。

4、属性不同

线程有自己的私有属性TCB，线程id，寄存器、硬件上下文，而进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志。

#### 并行与串行的区别

串行就是在主线程上按顺序执行逻辑代码

并行就是多个cpu同时工作来完成多个逻辑

#### java实现多线程的三种的方式

继承Thread类、实现Runnable接口、使用ExecutorService、Callable、Future实现有返回结果的多线程。其中前两种方式线程执行完后都没有返回值，只有最后一种是带返回值的。

####  线程常用API

| 方法            | 名称                                        |
| --------------- | ------------------------------------------- |
| start()         | 启动线程                                    |
| currentThread() | 获取当前线程对象                            |
| getId()         | 获取当前线程id                              |
| getName()       | 获取当前线程名称                            |
| sleep()         | 休眠线程                                    |
| stop()          | 停止线程 --不安全 --不推荐使用              |
| setDaemon()     | 改变线程状态:true-守护线程:flase-非守护线程 |
| join()          | 线程执行优先级                              |

#### 线程的生命周期

当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，它要经过 **新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）和死亡（Dead）5种状态**。尤其是当线程启动以后，它不可能一直"霸占"着CPU独自运行，所以CPU需要在多条线程之间切换，于是 线程状态也会多次在运行、阻塞之间切换。

1.当程序使用new关键字创建了一个线程之后，该线程就处于 **新建状态**

2.当线程对象调用了start()方法之后，该线程处于 **就绪状态**。

3.当CPU开始调度处于 **就绪状态** 的线程时，此时线程获得了CPU时间片才得以真正开始执行run()方法的线程执行体，则该线程处于 **运行状态**。

4.处于运行状态的线程在某些情况下，让出CPU并暂时停止自己的运行，进入 **阻塞状态**。

5.线程会以下三种方式结束就会进入**死亡状态**	

​	run()或call()方法执行完成，线程正常结束；

​	线程抛出一个未捕获的Exception或Error；

​	直接调用该线程stop()方法来结束该线程,—该方法容易导致死锁，通常不推荐使用；